/**
* TinyML Trainer Example. 
* Version: v005
*
* This is an example generated by Tiny Motion Trainer 
* It is pre-filled with your trained model and your capture settings 
* 
* Required Libraries:
* - TensorFlow Lite for Microcontrollers (tested with v2.4-beta)
* - Arduino_LSM9DS1
*
* Usage:
* - Make sure the Arduino BLE 33 board is installed (tools->board->Board Manager) and connected
* - Make sure you have the required libraries installed
* - Build and upload the sketch
* - Keep the Arduino connected via USB and open the Serial Monitor (Tools->Serial Monitor)
* - The sketch will log out the label with the highest score once detected.
*
* This is meant as an example for you to develop your own code, and is not production ready.
*
**/


//==============================================================================
// LED
//==============================================================================

//
//void rgbLedBlue()
//{
//  digitalWrite(LEDR, HIGH);
//  digitalWrite(LEDG, HIGH);
//  digitalWrite(LEDB, LOW);
//}
//
//void rgbLedRed()
//{
//  digitalWrite(LEDR, LOW);
//  digitalWrite(LEDG, HIGH);
//  digitalWrite(LEDB, HIGH);
//}
//
//void rgbLedGreen()
//{
//  digitalWrite(LEDR, HIGH);
//  digitalWrite(LEDG, LOW);
//  digitalWrite(LEDB, HIGH);
//}
//
//void rgbLedYellow()
//{
//  digitalWrite(LEDR, LOW);
//  digitalWrite(LEDG, LOW);
//  digitalWrite(LEDB, HIGH);
//}

//==============================================================================
// Includes
//==============================================================================

#include <ArduinoBLE.h>
#include <Arduino_LSM9DS1.h>
#include <TensorFlowLite.h>
#include <tensorflow/lite/micro/all_ops_resolver.h>
#include <tensorflow/lite/micro/micro_error_reporter.h>
#include <tensorflow/lite/micro/micro_interpreter.h>
#include <tensorflow/lite/schema/schema_generated.h>
#include <tensorflow/lite/version.h>


//==============================================================================
// Your custom data / settings
// - Editing these is not recommended
//==============================================================================

// This is the model you trained in Tiny Motion Trainer, converted to 
// a C style byte array.
#include "model.h"
#include "data_provider.h"

// Values from Tiny Motion Trainer
#define MOTION_THRESHOLD 0.2
#define CAPTURE_DELAY 200 // This is now in milliseconds
#define NUM_SAMPLES 20

// Array to map gesture index to a name
const char *GESTURES[] = {
    "chop", "slash", "guard", "up_slash"
};

/************************************************************************
* BLE Characteristic / Service UUIDs
************************************************************************/

#define LOCAL_NAME "IMMACUTYOU"
#define UUID_GEN(val) ("81c30e5c-" val "-4f7d-a886-de3e90749161")

BLECharCharacteristic *myChar = nullptr;
BLEService* myService = nullptr;


//==============================================================================
// Capture variables
//==============================================================================

#define NUM_GESTURES (sizeof(GESTURES) / sizeof(GESTURES[0]))

bool isCapturing = false;

// Num samples read from the IMU sensors
// "Full" by default to start in idle
int numSamplesRead = 0;


//==============================================================================
// TensorFlow variables
//==============================================================================

// Global variables used for TensorFlow Lite (Micro)
tflite::MicroErrorReporter tflErrorReporter;

// Auto resolve all the TensorFlow Lite for MicroInterpreters ops, for reduced memory-footprint change this to only 
// include the op's you need.
tflite::AllOpsResolver tflOpsResolver;

// Setup model
const tflite::Model* tflModel = nullptr;
tflite::MicroInterpreter* tflInterpreter = nullptr;
TfLiteTensor* tflInputTensor = nullptr;
TfLiteTensor* tflOutputTensor = nullptr;

// Create a static memory buffer for TensorFlow Lite for MicroInterpreters, the size may need to
// be adjusted based on the model you are using
constexpr int tensorArenaSize = 8 * 1024;
byte tensorArena[tensorArenaSize];


//==============================================================================
// Setup / Loop
//==============================================================================

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);

  myService = new BLEService(UUID_GEN("0000"));
  myChar = new BLECharCharacteristic(UUID_GEN("300b"), BLERead | BLENotify);
        
  Serial.begin(9600);


  // Start IMU / Data provider.
  if (!data_provider::setup())
  {
    Serial.println("Failed to initialize IMU!");
    while (1);
  }

  if (!BLE.begin()) {
    Serial.println("Failed to initialized BLE!");
    while (1);
  }

  String address = BLE.address();

  // Output BLE settings over Serial.
  Serial.print("address = ");
  Serial.println(address);

  address.toUpperCase();

  static String deviceName = LOCAL_NAME;
  deviceName += " - ";
  deviceName += address[address.length() - 5];
  deviceName += address[address.length() - 4];
  deviceName += address[address.length() - 2];
  deviceName += address[address.length() - 1];


  // start advertising
  // Set up properties for the whole service.
  BLE.setLocalName(deviceName.c_str());
  BLE.setDeviceName(deviceName.c_str());
  
  
  myService->addCharacteristic(*myChar);
  // set the initial value for the characeristic:
  myChar->writeValue(0);
  BLE.addService(*myService);
   
// set advertised local name and service UUID:
  BLE.setAdvertisedService(*myService); // add the service UUID
  
  // start advertising
  BLE.advertise();

  Serial.println("Bluetooth device active, waiting for connections...");

  // Get the TFL representation of the model byte array
  tflModel = tflite::GetModel(model);
  if (tflModel->version() != TFLITE_SCHEMA_VERSION) {
    Serial.println("Model schema mismatch!");
    while (1);
  }

  // Create an interpreter to run the model
  tflInterpreter = new tflite::MicroInterpreter(tflModel, tflOpsResolver, tensorArena, tensorArenaSize, &tflErrorReporter);

  // Allocate memory for the model's input and output tensors
  tflInterpreter->AllocateTensors();

  // Get pointers for the model's input and output tensors
  tflInputTensor = tflInterpreter->input(0);
  tflOutputTensor = tflInterpreter->output(0);
}

// Variables to hold IMU data
float aX, aY, aZ, gX, gY, gZ;

void loop() {
 
 
 BLEDevice central = BLE.central();

 if (central) {
  Serial.println("connected");
  while(central.connected()) {
    // Wait for motion above the threshold setting
    if (!isCapturing) {
      if (IMU.accelerationAvailable() && IMU.gyroscopeAvailable()) {
       
        IMU.readAcceleration(aX, aY, aZ);
        IMU.readGyroscope(gX, gY, gZ);
  
        // Sum absolute values
        float average = fabs(aX / 4.0) + fabs(aY / 4.0) + fabs(aZ / 4.0) + fabs(gX / 2000.0) + fabs(gY / 2000.0) + fabs(gZ / 2000.0);
        average /= 6.;
  
        // Above the threshold?
        if (average >= MOTION_THRESHOLD) {
          numSamplesRead = 0;
          isCapturing = true;
        }
      }
    }
  
    if (isCapturing) {
  
      // Check if both acceleration and gyroscope data is available
      if (IMU.accelerationAvailable() && IMU.gyroscopeAvailable()) {
  
        // read the acceleration and gyroscope data
        IMU.readAcceleration(aX, aY, aZ);
        IMU.readGyroscope(gX, gY, gZ);
  
        // Normalize the IMU data between -1 to 1 and store in the model's
        // input tensor. Accelerometer data ranges between -4 and 4,
        // gyroscope data ranges between -2000 and 2000
        tflInputTensor->data.f[numSamplesRead * 6 + 0] = aX / 4.0;
        tflInputTensor->data.f[numSamplesRead * 6 + 1] = aY / 4.0;
        tflInputTensor->data.f[numSamplesRead * 6 + 2] = aZ / 4.0;
        tflInputTensor->data.f[numSamplesRead * 6 + 3] = gX / 2000.0;
        tflInputTensor->data.f[numSamplesRead * 6 + 4] = gY / 2000.0;
        tflInputTensor->data.f[numSamplesRead * 6 + 5] = gZ / 2000.0;
  
        numSamplesRead++;
  
        // Do we have the samples we need?
        if (numSamplesRead == NUM_SAMPLES) {
          
          // Stop capturing
          isCapturing = false;
          
          // Run inference
          TfLiteStatus invokeStatus = tflInterpreter->Invoke();
          if (invokeStatus != kTfLiteOk) {
            Serial.println("Error: Invoke failed!");
            while (1);
            return;
          }
  
          // Loop through the output tensor values from the model
          int maxIndex = 0;
          float maxValue = 0;
          for (int i = 0; i < NUM_GESTURES; i++) {
            float _value = tflOutputTensor->data.f[i];
            if(_value > maxValue){
              maxValue = _value;
              maxIndex = i;
            }
            Serial.print(GESTURES[i]);
            Serial.print(": ");
            Serial.println(tflOutputTensor->data.f[i], 6);
          }
          
          Serial.print("Winner: ");
          Serial.print(GESTURES[maxIndex]);
          Serial.print(", maxIndex: ");
          Serial.print(maxIndex);
          myChar->writeValue(maxIndex);
          // Add delay to not double trigger
          delay(CAPTURE_DELAY);
        }
      }
    }
  }
  Serial.println("disconnected");
 }
}
